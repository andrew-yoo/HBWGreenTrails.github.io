# Nature Discussion Zone - Firebase Firestore Structure

## Overview
The Nature Discussion Zone feature allows users to have direct messages (DM) and group chats to discuss nature and environmental topics. This document outlines the Firebase Firestore structure required for this feature.

## Collections

### 1. `conversations`
This collection stores metadata about all conversations (both DMs and group chats).

#### Document Structure
```javascript
{
  // Document ID: Auto-generated by Firestore
  
  type: string,              // "dm" or "group"
  participants: string[],     // Array of usernames participating in the conversation
  createdAt: Timestamp,       // When the conversation was created
  createdBy: string,          // Username who created the conversation (for groups)
  lastMessageTime: Timestamp, // Timestamp of the most recent message
  lastMessage: string,        // Text of the most recent message (for preview)
  
  // Group-specific fields (only present when type === "group")
  groupName: string          // Name of the group chat (optional for DMs)
}
```

#### Example Documents

**Direct Message:**
```javascript
{
  type: "dm",
  participants: ["Alice", "Bob"],
  createdAt: Timestamp(2026-01-09 16:00:00),
  lastMessageTime: Timestamp(2026-01-09 16:30:00),
  lastMessage: "Looking forward to the next trail walk!"
}
```

**Group Chat:**
```javascript
{
  type: "group",
  groupName: "Bird Watchers",
  participants: ["Alice", "Bob", "Charlie"],
  createdBy: "Alice",
  createdAt: Timestamp(2026-01-09 15:00:00),
  lastMessageTime: Timestamp(2026-01-09 16:45:00),
  lastMessage: "Did anyone see the blue jay today?"
}
```

### 2. `conversations/{conversationId}/messages`
This is a subcollection under each conversation document that stores all messages for that conversation.

#### Document Structure
```javascript
{
  // Document ID: Auto-generated by Firestore
  
  senderId: string,      // Username of the person who sent the message
  text: string,          // Message content
  timestamp: Timestamp   // When the message was sent
}
```

#### Example Document
```javascript
{
  senderId: "Alice",
  text: "I saw a beautiful red-tailed hawk on my hike this morning!",
  timestamp: Timestamp(2026-01-09 16:30:00)
}
```

## Queries Used

### Finding Conversations for a User
```javascript
// Query conversations where the current user is a participant
const conversationsRef = collection(db, 'conversations');
const q = query(
    conversationsRef,
    where('participants', 'array-contains', currentUser),
    orderBy('lastMessageTime', 'desc')
);
```

### Finding Existing DM Conversation
```javascript
// Check if a DM already exists between two users
const conversationsRef = collection(db, 'conversations');
const q = query(
    conversationsRef,
    where('type', '==', 'dm'),
    where('participants', 'array-contains', currentUser)
);
// Then filter client-side to find the conversation with the other user
```

### Retrieving Messages
```javascript
// Get all messages for a conversation, ordered by timestamp
const messagesRef = collection(db, 'conversations', conversationId, 'messages');
const q = query(messagesRef, orderBy('timestamp', 'asc'));
```

## Security Considerations

### Recommended Firestore Security Rules
Add these rules to your Firestore security rules to protect user conversations:

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Conversations collection rules
    match /conversations/{conversationId} {
      // Users can only read conversations they're participating in
      allow read: if request.auth != null && 
                     resource.data.participants.hasAny([request.auth.token.name]);
      
      // Users can create new conversations if they're in the participants list
      allow create: if request.auth != null && 
                       request.resource.data.participants.hasAny([request.auth.token.name]);
      
      // Only participants can update conversation metadata
      allow update: if request.auth != null && 
                       resource.data.participants.hasAny([request.auth.token.name]);
      
      // Messages subcollection rules
      match /messages/{messageId} {
        // Participants can read all messages in their conversations
        allow read: if request.auth != null && 
                       get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants.hasAny([request.auth.token.name]);
        
        // Users can only create messages if they're participants and set themselves as sender
        allow create: if request.auth != null && 
                         get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants.hasAny([request.auth.token.name]) &&
                         request.resource.data.senderId == request.auth.token.name;
      }
    }
  }
}
```

**Note:** Since this app uses a simple username-based authentication system (stored in localStorage) rather than Firebase Authentication, you'll need to adapt these rules or implement proper Firebase Authentication to enforce these security measures effectively.

## Database Impact Assessment

### Write Operations
- **Creating a conversation**: 1 write to `conversations` collection
- **Sending a message**: 2 writes (1 to `messages` subcollection, 1 update to conversation's `lastMessage` and `lastMessageTime`)
- **Per active user per conversation**: ~2 writes per message sent

### Read Operations
- **Loading conversation list**: 1 read of all conversations where user is a participant
- **Loading messages**: 1 read of all messages in a conversation (uses real-time listener)
- **Initial page load**: ~2 reads per user (conversation list + user list for new DMs)

### Real-Time Listeners
- **Chat list**: 1 snapshot listener on `conversations` collection (filtered by current user)
- **Message view**: 1 snapshot listener on `conversations/{conversationId}/messages` subcollection
- These listeners use Firebase's efficient real-time updates and only send changed data

### Cost Optimization Tips
1. Messages use subcollections to avoid loading all messages when fetching conversations
2. Conversation list only loads metadata, not message content
3. Real-time listeners are cleaned up when components unmount
4. Pagination could be added to message loading if conversations grow very large

## User Experience Flow

### Direct Messaging
1. User clicks "New Direct Message"
2. Selects a user from the list
3. System checks if a DM conversation already exists between the two users
4. If exists, opens existing conversation; if not, creates new one
5. User can send and receive messages in real-time

### Group Chat
1. User clicks "New Group Chat"
2. Enters a group name and selects multiple participants
3. System creates new group conversation
4. User can send messages to all participants
5. All participants see messages in real-time

## Future Enhancements (Not Implemented)
- Message read receipts
- Typing indicators
- Image/file sharing
- Message reactions
- Conversation deletion
- User removal from groups
- Admin controls for groups
- Message search
- Push notifications
